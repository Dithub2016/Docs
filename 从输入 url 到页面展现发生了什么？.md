# 从输入 url 到页面展现发生了什么？

## 大致是如下步骤

1. 根据地址栏输入的地址向 DNS(Domain Name System) 查询 IP
2. 通过 IP 向服务器发起 TCP 连接
3. 向服务器发起请求
4. 服务器返回请求内容
5. 浏览器开始解析渲染页面并显示
6. 关闭连接



## DNS 域名系统（Domain Name System）

域名解析的过程是逐级查询的

1. 浏览器缓存
2. 操作系统缓存
3. 在 host 文件中查找
4. 路由器缓存
5. ISP DNS 缓存
6. 顶级 DNS 服务器/根 DNS 服务器



## TCP 连接

三次握手：

1. SYN
2. ACK/SYN
3. ACK



## HTTP 请求与响应

超文本传输协议（HyperText Transfer Protocol）

在应用层，浏览器会分析这个 url，并设置好请求报文发出。请求报文中包括请求行、请求头、空行、请求主体。https 默认请求商品 443，http 默认 80。

- **请求行**：请求行中包括请求的方法，路径和协议版本。
- **请求头**：请求头中包含了请求的一些附加的信息，一般是以键值的形式成对存在，比如设置请求文件的类型 accept-type，以及服务器对缓存的设置。
- **空行**：协议中规定请求头和请求主体间必须用一个空行隔开。
- **请求主体**：对于 post 请求，所需要的参数都不会放在 url 中，这时候就需要一个载体了，这个载体就是请求主题。

服务端收到请求之后，会根据 url 匹配到的路径做相应的处理，最后返回浏览器需要的页面资源。浏览器会收到一个响应报文，而所需要的资源就在报文主体上。与请求报文相同，响应报文也有与之对应的起始行、首部、空行、报文主体，不同的都应该在于包含的东西不一样。

- **响应行**：响应报文的起始行同样包含了协议版本，与请求的起始行不同的是其包含的还有状态码和状态码的原因短语。
- **响应头**：对应请求报文中的请求头，格式一致，但是各自有不同的首部。也有一起用的能用首部。
- **空行**
- **报文主体**：请求所需要的资源

### http 缓存 

请求是浏览器的一个优化点，我们可以通过缓存来减少不必要的请求，进而 lknw 页面的呈现。通过简单了设置 http 头部可以使用缓存的功能。一般有三种设置的方式

1. Last-Modify（响应头）+ If-Modified-Since（请求头）
2. ETap（响应头）+ If-None-Match（请求头）
3. Cache-Control/Expires（响应头）



## 页面呈现

至此浏览器已经拿到了一个 HTML 文档，并为了呈现文档而开始解析。呈现引擎开始工作，基本流程如下（以 webkit 为例）

- 通过 HTML 解析器解析 HTML 文档，构建一个 DOM Tree，同时通过 CSS 解析器解析 HTML 中存在的 CSS，构建 Style Rules，两者结合形成一个 Attachment。
- 通过 Attachment 构造出一个呈现树（Render Tree）
- Render Tree 构建完毕，进入到布局阶段（layout/reflow），将会为每个阶段分配一个应出现屏幕的确切坐标
- 最后将全部的节点遍历绘制出来后，一个页面就展现出来了。

需要注意的是，这是一个渐进的过程，呈现引擎为了力求显示的及时，会在文档请求不完全的情况下就开始渲染页面，同时，如果在解析的过程中遇到 script 的时候，文档的解析将会停止下来，立即解析执行脚本，如果脚本是外部的，则会等待请求完成并解析执行。所以，为了不阻塞页面的呈现，一般会把 script 脚本放在文档的最后。

在最新的 HTML4 和 HTML5 规范中，也可以将脚本标为 defer，这样就不会停止文档解析，而是等到解析完成后才执行。HTML5 增加了一个选项，可将脚本标记为 async，以便由期货线程解析和执行。

## 连接关闭

现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。这个关闭的过程就是著名的四次挥手。关闭是一个全双工的进程，发包的有顺序是一定的。一般来说是客户端主动发起的关闭，过程如下。。。